name: CI/CD Pipeline

on:
  pull_request:
    branches:
      - main
      - release  # PR을 main 또는 release 브랜치로 할 때만 CI가 실행되도록 설정

  push:
    branches:
      - main
      - release  # main 혹은 release 브랜치에 푸시될 때만 배포가 실행되도록 설정

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      # 1. 저장소 클론
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Java 설정
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: 21
          distribution: 'temurin'

      # 3. secrets 내용을 읽어 yml 파일과 keystore 파일을 동시에 생성
      - name: Create application.yml and decrypt keystore.p12
        run: |
          sed -i "s|\${DOMAIN}|${{ secrets.DOMAIN }}|g" ./src/main/resources/application.yml
          sed -i "s|\${REDIRECT_URL}|${{ secrets.REDIRECT_URL }}|g" ./src/main/resources/application.yml
          sed -i "s|\${KEY_STORE}|${{ secrets.KEY_STORE }}|g" ./src/main/resources/application.yml
          sed -i "s|\${KEY_STORE_TYPE}|${{ secrets.KEY_STORE_TYPE }}|g" ./src/main/resources/application.yml
          sed -i "s|\${KEY_STORE_PASS}|${{ secrets.KEY_STORE_PASS }}|g" ./src/main/resources/application.yml
          sed -i "s|\${DB_USERNAME}|${{ secrets.DB_USERNAME }}|g" ./src/main/resources/application.yml
          sed -i "s|\${DB_PASSWORD}|${{ secrets.DB_PASSWORD }}|g" ./src/main/resources/application.yml
          sed -i "s|\${JWT_SECRET}|${{ secrets.JWT_SECRET }}|g" ./src/main/resources/application.yml

          sed -i "s|\${GOOGLE_CLIENT_ID}|${{ secrets.GOOGLE_CLIENT_ID }}|g" ./src/main/resources/application.yml
          sed -i "s|\${GOOGLE_CLIENT_SECRET}|${{ secrets.GOOGLE_CLIENT_SECRET }}|g" ./src/main/resources/application.yml
          
          sed -i "s|\${KAKAO_CLIENT_ID}|${{ secrets.KAKAO_CLIENT_ID }}|g" ./src/main/resources/application.yml
          sed -i "s|\${KAKAO_CLIENT_SECRET}|${{ secrets.KAKAO_CLIENT_SECRET }}|g" ./src/main/resources/application.yml
          
          sed -i "s|\${NAVER_CLIENT_ID}|${{ secrets.NAVER_CLIENT_ID }}|g" ./src/main/resources/application.yml
          sed -i "s|\${NAVER_CLIENT_SECRET}|${{ secrets.NAVER_CLIENT_SECRET }}|g" ./src/main/resources/application.yml
          
          echo "${{ secrets.KEYSTORE_FILE }}" | base64 --decode > ./src/main/resources/keystore.p12

      # 4. Gradle 빌드 (테스트 제외)
      - name: Build with Gradle
        run: |
          chmod +x ./gradlew
          ./gradlew clean build -x test

      # 5. Docker 이미지 빌드 및 Docker Hub에 푸시
      - name: Build and Push Docker Image
        run: |
          echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          docker build -t ${{ secrets.DOCKER_USERNAME }}/my-spring-app .
          docker push ${{ secrets.DOCKER_USERNAME }}/my-spring-app


  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/release'  # main 혹은 release 브랜치에만 배포가 실행되도록 설정

    steps:
      # 1. EC2 서버에 Docker Compose 배포
      - name: Deploy on EC2 with Docker Compose
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_KEY: ${{ secrets.EC2_KEY }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        run: |
          # EC2 서버 키 설정 및 권한 설정
          echo "${EC2_KEY}" > ec2-key.pem
          chmod 600 ec2-key.pem
          mkdir -p ~/.ssh
          ssh-keyscan -H ${EC2_HOST} >> ~/.ssh/known_hosts

          # EC2 서버에서 작업 실행
          ssh -i ec2-key.pem -t ${EC2_USER}@${EC2_HOST} << EOF
            # Git 리포지토리 경로로 이동
            cd /home/${EC2_USER}/docker

            # 최신 코드 가져오기
            git pull origin main

            # 최신 Docker 이미지 가져오기
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${DOCKER_USERNAME}" --password-stdin

            # 기존 컨테이너 중지 및 삭제
            cd /home/${EC2_USER}/docker
            docker-compose down

            # 새 컨테이너 실행
            docker-compose up -d --force-recreate
          EOF

          # EC2 서버 키 삭제
          rm -f ec2-key.pem