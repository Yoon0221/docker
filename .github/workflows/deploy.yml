name: CI/CD Pipeline

on:
  pull_request:
    branches:
      - main
      - release  # PR을 main 또는 release 브랜치로 할 때만 CI가 실행되도록 설정

  push:
    branches:
      - main
      - release  # main 혹은 release 브랜치에 푸시될 때만 배포가 실행되도록 설정

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      # 1. 저장소 클론
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Java 설정
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: 21
          distribution: 'temurin'

      # 3. secrets 내용을 읽어 yml 파일과 keystore 파일을 동시에 생성
      - name: Create application.yml and decrypt keystore.p12
        run: |
          cp ./src/main/resources/application.yml ./src/main/resources/application_backup.yml

          sed -i "s|\${DOMAIN}|${{ secrets.DOMAIN }}|g" ./src/main/resources/application.yml
          sed -i "s|\${REDIRECT_URL}|${{ secrets.REDIRECT_URL }}|g" ./src/main/resources/application.yml
          sed -i "s|\${KEY_STORE}|${{ secrets.KEY_STORE }}|g" ./src/main/resources/application.yml
          sed -i "s|\${KEY_STORE_TYPE}|${{ secrets.KEY_STORE_TYPE }}|g" ./src/main/resources/application.yml
          sed -i "s|\${KEY_STORE_PASS}|${{ secrets.KEY_STORE_PASS }}|g" ./src/main/resources/application.yml
          sed -i "s|\${DB_USERNAME}|${{ secrets.DB_USERNAME }}|g" ./src/main/resources/application.yml
          sed -i "s|\${DB_PASSWORD}|${{ secrets.DB_PASSWORD }}|g" ./src/main/resources/application.yml
          sed -i "s|\${JWT_SECRET}|${{ secrets.JWT_SECRET }}|g" ./src/main/resources/application.yml

          sed -i "s|\${GOOGLE_CLIENT_ID}|${{ secrets.GOOGLE_CLIENT_ID }}|g" ./src/main/resources/application.yml
          sed -i "s|\${GOOGLE_CLIENT_SECRET}|${{ secrets.GOOGLE_CLIENT_SECRET }}|g" ./src/main/resources/application.yml
          
          sed -i "s|\${KAKAO_CLIENT_ID}|${{ secrets.KAKAO_CLIENT_ID }}|g" ./src/main/resources/application.yml
          sed -i "s|\${KAKAO_CLIENT_SECRET}|${{ secrets.KAKAO_CLIENT_SECRET }}|g" ./src/main/resources/application.yml
          
          sed -i "s|\${NAVER_CLIENT_ID}|${{ secrets.NAVER_CLIENT_ID }}|g" ./src/main/resources/application.yml
          sed -i "s|\${NAVER_CLIENT_SECRET}|${{ secrets.NAVER_CLIENT_SECRET }}|g" ./src/main/resources/application.yml
          
          echo "${{ secrets.KEYSTORE_FILE }}" | base64 --decode > ./src/main/resources/keystore.p12

      # 4. Gradle 빌드 (테스트 제외)
      - name: Build with Gradle
        run: |
          chmod +x ./gradlew
          ./gradlew clean build -x test

      # 5. JAR 파일 업로드
      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ secrets.APP_NAME }}
          path: build/libs/${{ secrets.APP_JAR_NAME }}

  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/release'  # main 혹은 release 브랜치에만 배포

    steps:
      # 1. JAR 파일 다운로드
      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ secrets.APP_NAME }}

      # 2. EC2 서버로 JAR 파일 및 SSL 인증서 복사
      - name: Copy JAR and SSL certificate to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_KEY: ${{ secrets.EC2_KEY }}
          SSL_KEY_PATH: ${{ secrets.SSL_KEY_PATH }}
          APP_JAR_NAME: ${{ secrets.APP_JAR_NAME }}
        run: |
          echo "${EC2_KEY}" > ec2-key.pem
          chmod 600 ec2-key.pem
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
          rsync -avz -e "ssh -i ec2-key.pem" ${{ secrets.APP_JAR_NAME }} ${EC2_USER}@${EC2_HOST}:/home/${EC2_USER}/
          rsync -avz -e "ssh -i ec2-key.pem" ${SSL_KEY_PATH} ${EC2_USER}@${EC2_HOST}:/home/${EC2_USER}/
          rm -f ec2-key.pem

      # 3. EC2 서버에서 애플리케이션 실행
      - name: Deploy on EC2 with HTTPS
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_KEY: ${{ secrets.EC2_KEY }}
          APP_JAR_NAME: ${{ secrets.APP_JAR_NAME }}
          APP_LOG_NAME: ${{ secrets.APP_LOG_NAME }}
        run: |
          echo "${EC2_KEY}" > ec2-key.pem
          chmod 600 ec2-key.pem
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
          ssh -i ec2-key.pem ${EC2_USER}@${EC2_HOST} << EOF
            sudo pkill -f '${APP_JAR_NAME}' || true
            sudo java -jar /home/${EC2_USER}/${APP_JAR_NAME} &> /home/${EC2_USER}/${APP_LOG_NAME} &  # 백그라운드 실행
          EOF
          rm -f ec2-key.pem